"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3";
exports.ids = ["vendor-chunks/rou3"];
exports.modules = {

/***/ "(action-browser)/../../../node_modules/rou3/dist/index.mjs":
/*!*************************************************!*\
  !*** ../../../node_modules/rou3/dist/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute)\n/* harmony export */ });\nconst EmptyObject = /* @__PURE__ */ (() => {\n  const C = function() {\n  };\n  C.prototype = /* @__PURE__ */ Object.create(null);\n  return C;\n})();\n\nfunction createRouter() {\n  const ctx = {\n    root: { key: \"\" },\n    static: new EmptyObject()\n  };\n  return ctx;\n}\n\nfunction splitPath(path) {\n  return path.split(\"/\").filter(Boolean);\n}\nfunction getMatchParams(segments, paramsMap) {\n  const params = new EmptyObject();\n  for (const [index, name] of paramsMap) {\n    const segment = index < 0 ? segments.slice(-1 * index).join(\"/\") : segments[index];\n    if (typeof name === \"string\") {\n      params[name] = segment;\n    } else {\n      const match = segment.match(name);\n      if (match) {\n        for (const key in match.groups) {\n          params[key] = match.groups[key];\n        }\n      }\n    }\n  }\n  return params;\n}\n\nfunction addRoute(ctx, method = \"\", path, data) {\n  const segments = splitPath(path);\n  let node = ctx.root;\n  let _unnamedParamIndex = 0;\n  const paramsMap = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment.startsWith(\"**\")) {\n      if (!node.wildcard) {\n        node.wildcard = { key: \"**\" };\n      }\n      node = node.wildcard;\n      paramsMap.push([\n        -i,\n        segment.split(\":\")[1] || \"_\",\n        segment.length === 2\n      ]);\n      break;\n    }\n    if (segment === \"*\" || segment.includes(\":\")) {\n      if (!node.param) {\n        node.param = { key: \"*\" };\n      }\n      node = node.param;\n      const isOptional = segment === \"*\";\n      paramsMap.push([\n        i,\n        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),\n        isOptional\n      ]);\n      continue;\n    }\n    const child = node.static?.[segment];\n    if (child) {\n      node = child;\n    } else {\n      const staticNode = { key: segment };\n      if (!node.static) {\n        node.static = new EmptyObject();\n      }\n      node.static[segment] = staticNode;\n      node = staticNode;\n    }\n  }\n  const hasParams = paramsMap.length > 0;\n  if (!node.methods) {\n    node.methods = new EmptyObject();\n  }\n  if (!node.methods[method]) {\n    node.methods[method] = [];\n  }\n  node.methods[method].push({\n    data: data || null,\n    paramsMap: hasParams ? paramsMap : void 0\n  });\n  if (!hasParams) {\n    ctx.static[path] = node;\n  }\n}\nfunction _getParamMatcher(segment) {\n  if (!segment.includes(\":\", 1)) {\n    return segment.slice(1);\n  }\n  const regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>\\\\w+)`);\n  return new RegExp(`^${regex}$`);\n}\n\nfunction findRoute(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const staticNode = ctx.static[path];\n  if (staticNode && staticNode.methods) {\n    const staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n    if (staticMatch !== void 0) {\n      return staticMatch[0];\n    }\n  }\n  const segments = splitPath(path);\n  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n  if (match === void 0) {\n    return;\n  }\n  if (opts?.params === false) {\n    return match;\n  }\n  return {\n    data: match.data,\n    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n  };\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods) {\n      const match = node.methods[method] || node.methods[\"\"];\n      if (match) {\n        return match;\n      }\n    }\n    if (node.param && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    if (node.wildcard && node.wildcard.methods) {\n      const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    return void 0;\n  }\n  const segment = segments[index];\n  if (node.static) {\n    const staticChild = node.static[segment];\n    if (staticChild) {\n      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n      if (match) {\n        return match;\n      }\n    }\n  }\n  if (node.param) {\n    const match = _lookupTree(ctx, node.param, method, segments, index + 1);\n    if (match) {\n      return match;\n    }\n  }\n  if (node.wildcard && node.wildcard.methods) {\n    return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n  }\n  return;\n}\n\nfunction removeRoute(ctx, method, path) {\n  const segments = splitPath(path);\n  return _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods && method in node.methods) {\n      delete node.methods[method];\n      if (Object.keys(node.methods).length === 0) {\n        node.methods = void 0;\n      }\n    }\n    return;\n  }\n  const segment = segments[index];\n  if (segment === \"*\") {\n    if (node.param) {\n      _remove(node.param, method, segments, index + 1);\n      if (_isEmptyNode(node.param)) {\n        node.param = void 0;\n      }\n    }\n    return;\n  }\n  if (segment === \"**\") {\n    if (node.wildcard) {\n      _remove(node.wildcard, method, segments, index + 1);\n      if (_isEmptyNode(node.wildcard)) {\n        node.wildcard = void 0;\n      }\n    }\n    return;\n  }\n  const childNode = node.static?.[segment];\n  if (childNode) {\n    _remove(childNode, method, segments, index + 1);\n    if (_isEmptyNode(childNode)) {\n      delete node.static[segment];\n      if (Object.keys(node.static).length === 0) {\n        node.static = void 0;\n      }\n    }\n  }\n}\nfunction _isEmptyNode(node) {\n  return node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const segments = splitPath(path);\n  const matches = _findAll(ctx, ctx.root, method, segments, 0);\n  if (opts?.params === false) {\n    return matches;\n  }\n  return matches.map((m) => {\n    return {\n      data: m.data,\n      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n    };\n  });\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n  const segment = segments[index];\n  if (node.wildcard && node.wildcard.methods) {\n    const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  if (node.param) {\n    _findAll(ctx, node.param, method, segments, index + 1, matches);\n    if (index === segments.length && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        matches.push(...match);\n      }\n    }\n  }\n  const staticChild = node.static?.[segment];\n  if (staticChild) {\n    _findAll(ctx, staticChild, method, segments, index + 1, matches);\n  }\n  if (index === segments.length && node.methods) {\n    const match = node.methods[method] || node.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  return matches;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsR0FBRztBQUMvRCx3QkFBd0IsTUFBTTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BoZWxzYS9hcHAvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JvdTMvZGlzdC9pbmRleC5tanM/MDA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFbXB0eU9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBjb25zdCBDID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIEMucHJvdG90eXBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBDO1xufSkoKTtcblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyKCkge1xuICBjb25zdCBjdHggPSB7XG4gICAgcm9vdDogeyBrZXk6IFwiXCIgfSxcbiAgICBzdGF0aWM6IG5ldyBFbXB0eU9iamVjdCgpXG4gIH07XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgcGFyYW1zTWFwKSB7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBFbXB0eU9iamVjdCgpO1xuICBmb3IgKGNvbnN0IFtpbmRleCwgbmFtZV0gb2YgcGFyYW1zTWFwKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGluZGV4IDwgMCA/IHNlZ21lbnRzLnNsaWNlKC0xICogaW5kZXgpLmpvaW4oXCIvXCIpIDogc2VnbWVudHNbaW5kZXhdO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyYW1zW25hbWVdID0gc2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKG5hbWUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hdGNoLmdyb3Vwcykge1xuICAgICAgICAgIHBhcmFtc1trZXldID0gbWF0Y2guZ3JvdXBzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gYWRkUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBkYXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBsZXQgbm9kZSA9IGN0eC5yb290O1xuICBsZXQgX3VubmFtZWRQYXJhbUluZGV4ID0gMDtcbiAgY29uc3QgcGFyYW1zTWFwID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aChcIioqXCIpKSB7XG4gICAgICBpZiAoIW5vZGUud2lsZGNhcmQpIHtcbiAgICAgICAgbm9kZS53aWxkY2FyZCA9IHsga2V5OiBcIioqXCIgfTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLndpbGRjYXJkO1xuICAgICAgcGFyYW1zTWFwLnB1c2goW1xuICAgICAgICAtaSxcbiAgICAgICAgc2VnbWVudC5zcGxpdChcIjpcIilbMV0gfHwgXCJfXCIsXG4gICAgICAgIHNlZ21lbnQubGVuZ3RoID09PSAyXG4gICAgICBdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudCA9PT0gXCIqXCIgfHwgc2VnbWVudC5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgIGlmICghbm9kZS5wYXJhbSkge1xuICAgICAgICBub2RlLnBhcmFtID0geyBrZXk6IFwiKlwiIH07XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJhbTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBzZWdtZW50ID09PSBcIipcIjtcbiAgICAgIHBhcmFtc01hcC5wdXNoKFtcbiAgICAgICAgaSxcbiAgICAgICAgaXNPcHRpb25hbCA/IGBfJHtfdW5uYW1lZFBhcmFtSW5kZXgrK31gIDogX2dldFBhcmFtTWF0Y2hlcihzZWdtZW50KSxcbiAgICAgICAgaXNPcHRpb25hbFxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgbm9kZSA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0aWNOb2RlID0geyBrZXk6IHNlZ21lbnQgfTtcbiAgICAgIGlmICghbm9kZS5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3RhdGljW3NlZ21lbnRdID0gc3RhdGljTm9kZTtcbiAgICAgIG5vZGUgPSBzdGF0aWNOb2RlO1xuICAgIH1cbiAgfVxuICBjb25zdCBoYXNQYXJhbXMgPSBwYXJhbXNNYXAubGVuZ3RoID4gMDtcbiAgaWYgKCFub2RlLm1ldGhvZHMpIHtcbiAgICBub2RlLm1ldGhvZHMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgfVxuICBpZiAoIW5vZGUubWV0aG9kc1ttZXRob2RdKSB7XG4gICAgbm9kZS5tZXRob2RzW21ldGhvZF0gPSBbXTtcbiAgfVxuICBub2RlLm1ldGhvZHNbbWV0aG9kXS5wdXNoKHtcbiAgICBkYXRhOiBkYXRhIHx8IG51bGwsXG4gICAgcGFyYW1zTWFwOiBoYXNQYXJhbXMgPyBwYXJhbXNNYXAgOiB2b2lkIDBcbiAgfSk7XG4gIGlmICghaGFzUGFyYW1zKSB7XG4gICAgY3R4LnN0YXRpY1twYXRoXSA9IG5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIF9nZXRQYXJhbU1hdGNoZXIoc2VnbWVudCkge1xuICBpZiAoIXNlZ21lbnQuaW5jbHVkZXMoXCI6XCIsIDEpKSB7XG4gICAgcmV0dXJuIHNlZ21lbnQuc2xpY2UoMSk7XG4gIH1cbiAgY29uc3QgcmVnZXggPSBzZWdtZW50LnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGlkKSA9PiBgKD88JHtpZH0+XFxcXHcrKWApO1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuXG5mdW5jdGlvbiBmaW5kUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIGNvbnN0IHN0YXRpY05vZGUgPSBjdHguc3RhdGljW3BhdGhdO1xuICBpZiAoc3RhdGljTm9kZSAmJiBzdGF0aWNOb2RlLm1ldGhvZHMpIHtcbiAgICBjb25zdCBzdGF0aWNNYXRjaCA9IHN0YXRpY05vZGUubWV0aG9kc1ttZXRob2RdIHx8IHN0YXRpY05vZGUubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAoc3RhdGljTWF0Y2ggIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRpY01hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIGN0eC5yb290LCBtZXRob2QsIHNlZ21lbnRzLCAwKT8uWzBdO1xuICBpZiAobWF0Y2ggPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRjaDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IG1hdGNoLmRhdGEsXG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbWF0Y2gucGFyYW1zTWFwKSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gX2xvb2t1cFRyZWUoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgIGlmIChub2RlLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucGFyYW0gJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuICAgICAgICBpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuICAgICAgICBpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuICAgIGlmIChzdGF0aWNDaGlsZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIHN0YXRpY0NoaWxkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICBjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgcmV0dXJuIG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgfVxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJvdXRlKGN0eCwgbWV0aG9kLCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICByZXR1cm4gX3JlbW92ZShjdHgucm9vdCwgbWV0aG9kIHx8IFwiXCIsIHNlZ21lbnRzLCAwKTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAobm9kZS5tZXRob2RzICYmIG1ldGhvZCBpbiBub2RlLm1ldGhvZHMpIHtcbiAgICAgIGRlbGV0ZSBub2RlLm1ldGhvZHNbbWV0aG9kXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLm1ldGhvZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLm1ldGhvZHMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICBpZiAobm9kZS5wYXJhbSkge1xuICAgICAgX3JlbW92ZShub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKF9pc0VtcHR5Tm9kZShub2RlLnBhcmFtKSkge1xuICAgICAgICBub2RlLnBhcmFtID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNlZ21lbnQgPT09IFwiKipcIikge1xuICAgIGlmIChub2RlLndpbGRjYXJkKSB7XG4gICAgICBfcmVtb3ZlKG5vZGUud2lsZGNhcmQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgICBpZiAoX2lzRW1wdHlOb2RlKG5vZGUud2lsZGNhcmQpKSB7XG4gICAgICAgIG5vZGUud2lsZGNhcmQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGlsZE5vZGUgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICBpZiAoY2hpbGROb2RlKSB7XG4gICAgX3JlbW92ZShjaGlsZE5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgaWYgKF9pc0VtcHR5Tm9kZShjaGlsZE5vZGUpKSB7XG4gICAgICBkZWxldGUgbm9kZS5zdGF0aWNbc2VnbWVudF07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5zdGF0aWMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLnN0YXRpYyA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc0VtcHR5Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLm1ldGhvZHMgPT09IHZvaWQgMCAmJiBub2RlLnN0YXRpYyA9PT0gdm9pZCAwICYmIG5vZGUucGFyYW0gPT09IHZvaWQgMCAmJiBub2RlLndpbGRjYXJkID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxSb3V0ZXMoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBjb25zdCBtYXRjaGVzID0gX2ZpbmRBbGwoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk7XG4gIGlmIChvcHRzPy5wYXJhbXMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG0uZGF0YSxcbiAgICAgIHBhcmFtczogbS5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbS5wYXJhbXNNYXApIDogdm9pZCAwXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZmluZEFsbChjdHgsIG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4LCBtYXRjaGVzID0gW10pIHtcbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5wYXJhbSkge1xuICAgIF9maW5kQWxsKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcbiAgICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLnBhcmFtLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5wYXJhbS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5wYXJhbS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRpY0NoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgaWYgKHN0YXRpY0NoaWxkKSB7XG4gICAgX2ZpbmRBbGwoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcbiAgfVxuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLm1ldGhvZHMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5leHBvcnQgeyBhZGRSb3V0ZSwgY3JlYXRlUm91dGVyLCBmaW5kQWxsUm91dGVzLCBmaW5kUm91dGUsIHJlbW92ZVJvdXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../../node_modules/rou3/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/rou3/dist/index.mjs":
/*!*************************************************!*\
  !*** ../../../node_modules/rou3/dist/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute)\n/* harmony export */ });\nconst EmptyObject = /* @__PURE__ */ (() => {\n  const C = function() {\n  };\n  C.prototype = /* @__PURE__ */ Object.create(null);\n  return C;\n})();\n\nfunction createRouter() {\n  const ctx = {\n    root: { key: \"\" },\n    static: new EmptyObject()\n  };\n  return ctx;\n}\n\nfunction splitPath(path) {\n  return path.split(\"/\").filter(Boolean);\n}\nfunction getMatchParams(segments, paramsMap) {\n  const params = new EmptyObject();\n  for (const [index, name] of paramsMap) {\n    const segment = index < 0 ? segments.slice(-1 * index).join(\"/\") : segments[index];\n    if (typeof name === \"string\") {\n      params[name] = segment;\n    } else {\n      const match = segment.match(name);\n      if (match) {\n        for (const key in match.groups) {\n          params[key] = match.groups[key];\n        }\n      }\n    }\n  }\n  return params;\n}\n\nfunction addRoute(ctx, method = \"\", path, data) {\n  const segments = splitPath(path);\n  let node = ctx.root;\n  let _unnamedParamIndex = 0;\n  const paramsMap = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment.startsWith(\"**\")) {\n      if (!node.wildcard) {\n        node.wildcard = { key: \"**\" };\n      }\n      node = node.wildcard;\n      paramsMap.push([\n        -i,\n        segment.split(\":\")[1] || \"_\",\n        segment.length === 2\n      ]);\n      break;\n    }\n    if (segment === \"*\" || segment.includes(\":\")) {\n      if (!node.param) {\n        node.param = { key: \"*\" };\n      }\n      node = node.param;\n      const isOptional = segment === \"*\";\n      paramsMap.push([\n        i,\n        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),\n        isOptional\n      ]);\n      continue;\n    }\n    const child = node.static?.[segment];\n    if (child) {\n      node = child;\n    } else {\n      const staticNode = { key: segment };\n      if (!node.static) {\n        node.static = new EmptyObject();\n      }\n      node.static[segment] = staticNode;\n      node = staticNode;\n    }\n  }\n  const hasParams = paramsMap.length > 0;\n  if (!node.methods) {\n    node.methods = new EmptyObject();\n  }\n  if (!node.methods[method]) {\n    node.methods[method] = [];\n  }\n  node.methods[method].push({\n    data: data || null,\n    paramsMap: hasParams ? paramsMap : void 0\n  });\n  if (!hasParams) {\n    ctx.static[path] = node;\n  }\n}\nfunction _getParamMatcher(segment) {\n  if (!segment.includes(\":\", 1)) {\n    return segment.slice(1);\n  }\n  const regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>\\\\w+)`);\n  return new RegExp(`^${regex}$`);\n}\n\nfunction findRoute(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const staticNode = ctx.static[path];\n  if (staticNode && staticNode.methods) {\n    const staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n    if (staticMatch !== void 0) {\n      return staticMatch[0];\n    }\n  }\n  const segments = splitPath(path);\n  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n  if (match === void 0) {\n    return;\n  }\n  if (opts?.params === false) {\n    return match;\n  }\n  return {\n    data: match.data,\n    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n  };\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods) {\n      const match = node.methods[method] || node.methods[\"\"];\n      if (match) {\n        return match;\n      }\n    }\n    if (node.param && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    if (node.wildcard && node.wildcard.methods) {\n      const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    return void 0;\n  }\n  const segment = segments[index];\n  if (node.static) {\n    const staticChild = node.static[segment];\n    if (staticChild) {\n      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n      if (match) {\n        return match;\n      }\n    }\n  }\n  if (node.param) {\n    const match = _lookupTree(ctx, node.param, method, segments, index + 1);\n    if (match) {\n      return match;\n    }\n  }\n  if (node.wildcard && node.wildcard.methods) {\n    return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n  }\n  return;\n}\n\nfunction removeRoute(ctx, method, path) {\n  const segments = splitPath(path);\n  return _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods && method in node.methods) {\n      delete node.methods[method];\n      if (Object.keys(node.methods).length === 0) {\n        node.methods = void 0;\n      }\n    }\n    return;\n  }\n  const segment = segments[index];\n  if (segment === \"*\") {\n    if (node.param) {\n      _remove(node.param, method, segments, index + 1);\n      if (_isEmptyNode(node.param)) {\n        node.param = void 0;\n      }\n    }\n    return;\n  }\n  if (segment === \"**\") {\n    if (node.wildcard) {\n      _remove(node.wildcard, method, segments, index + 1);\n      if (_isEmptyNode(node.wildcard)) {\n        node.wildcard = void 0;\n      }\n    }\n    return;\n  }\n  const childNode = node.static?.[segment];\n  if (childNode) {\n    _remove(childNode, method, segments, index + 1);\n    if (_isEmptyNode(childNode)) {\n      delete node.static[segment];\n      if (Object.keys(node.static).length === 0) {\n        node.static = void 0;\n      }\n    }\n  }\n}\nfunction _isEmptyNode(node) {\n  return node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const segments = splitPath(path);\n  const matches = _findAll(ctx, ctx.root, method, segments, 0);\n  if (opts?.params === false) {\n    return matches;\n  }\n  return matches.map((m) => {\n    return {\n      data: m.data,\n      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n    };\n  });\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n  const segment = segments[index];\n  if (node.wildcard && node.wildcard.methods) {\n    const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  if (node.param) {\n    _findAll(ctx, node.param, method, segments, index + 1, matches);\n    if (index === segments.length && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        matches.push(...match);\n      }\n    }\n  }\n  const staticChild = node.static?.[segment];\n  if (staticChild) {\n    _findAll(ctx, staticChild, method, segments, index + 1, matches);\n  }\n  if (index === segments.length && node.methods) {\n    const match = node.methods[method] || node.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  return matches;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JvdTMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEdBQUc7QUFDL0Qsd0JBQXdCLE1BQU07QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AaGVsc2EvYXBwLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yb3UzL2Rpc3QvaW5kZXgubWpzP2NiY2UiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRW1wdHlPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3QgQyA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICBDLnByb3RvdHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gQztcbn0pKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcigpIHtcbiAgY29uc3QgY3R4ID0ge1xuICAgIHJvb3Q6IHsga2V5OiBcIlwiIH0sXG4gICAgc3RhdGljOiBuZXcgRW1wdHlPYmplY3QoKVxuICB9O1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiBzcGxpdFBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIHBhcmFtc01hcCkge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIG5hbWVdIG9mIHBhcmFtc01hcCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBpbmRleCA8IDAgPyBzZWdtZW50cy5zbGljZSgtMSAqIGluZGV4KS5qb2luKFwiL1wiKSA6IHNlZ21lbnRzW2luZGV4XTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhcmFtc1tuYW1lXSA9IHNlZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc2VnbWVudC5tYXRjaChuYW1lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXRjaC5ncm91cHMpIHtcbiAgICAgICAgICBwYXJhbXNba2V5XSA9IG1hdGNoLmdyb3Vwc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgZGF0YSkge1xuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgbGV0IG5vZGUgPSBjdHgucm9vdDtcbiAgbGV0IF91bm5hbWVkUGFyYW1JbmRleCA9IDA7XG4gIGNvbnN0IHBhcmFtc01hcCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoXCIqKlwiKSkge1xuICAgICAgaWYgKCFub2RlLndpbGRjYXJkKSB7XG4gICAgICAgIG5vZGUud2lsZGNhcmQgPSB7IGtleTogXCIqKlwiIH07XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS53aWxkY2FyZDtcbiAgICAgIHBhcmFtc01hcC5wdXNoKFtcbiAgICAgICAgLWksXG4gICAgICAgIHNlZ21lbnQuc3BsaXQoXCI6XCIpWzFdIHx8IFwiX1wiLFxuICAgICAgICBzZWdtZW50Lmxlbmd0aCA9PT0gMlxuICAgICAgXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiKlwiIHx8IHNlZ21lbnQuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICBpZiAoIW5vZGUucGFyYW0pIHtcbiAgICAgICAgbm9kZS5wYXJhbSA9IHsga2V5OiBcIipcIiB9O1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyYW07XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gc2VnbWVudCA9PT0gXCIqXCI7XG4gICAgICBwYXJhbXNNYXAucHVzaChbXG4gICAgICAgIGksXG4gICAgICAgIGlzT3B0aW9uYWwgPyBgXyR7X3VubmFtZWRQYXJhbUluZGV4Kyt9YCA6IF9nZXRQYXJhbU1hdGNoZXIoc2VnbWVudCksXG4gICAgICAgIGlzT3B0aW9uYWxcbiAgICAgIF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGljTm9kZSA9IHsga2V5OiBzZWdtZW50IH07XG4gICAgICBpZiAoIW5vZGUuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gbmV3IEVtcHR5T2JqZWN0KCk7XG4gICAgICB9XG4gICAgICBub2RlLnN0YXRpY1tzZWdtZW50XSA9IHN0YXRpY05vZGU7XG4gICAgICBub2RlID0gc3RhdGljTm9kZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFzUGFyYW1zID0gcGFyYW1zTWFwLmxlbmd0aCA+IDA7XG4gIGlmICghbm9kZS5tZXRob2RzKSB7XG4gICAgbm9kZS5tZXRob2RzID0gbmV3IEVtcHR5T2JqZWN0KCk7XG4gIH1cbiAgaWYgKCFub2RlLm1ldGhvZHNbbWV0aG9kXSkge1xuICAgIG5vZGUubWV0aG9kc1ttZXRob2RdID0gW107XG4gIH1cbiAgbm9kZS5tZXRob2RzW21ldGhvZF0ucHVzaCh7XG4gICAgZGF0YTogZGF0YSB8fCBudWxsLFxuICAgIHBhcmFtc01hcDogaGFzUGFyYW1zID8gcGFyYW1zTWFwIDogdm9pZCAwXG4gIH0pO1xuICBpZiAoIWhhc1BhcmFtcykge1xuICAgIGN0eC5zdGF0aWNbcGF0aF0gPSBub2RlO1xuICB9XG59XG5mdW5jdGlvbiBfZ2V0UGFyYW1NYXRjaGVyKHNlZ21lbnQpIHtcbiAgaWYgKCFzZWdtZW50LmluY2x1ZGVzKFwiOlwiLCAxKSkge1xuICAgIHJldHVybiBzZWdtZW50LnNsaWNlKDEpO1xuICB9XG4gIGNvbnN0IHJlZ2V4ID0gc2VnbWVudC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBpZCkgPT4gYCg/PCR7aWR9PlxcXFx3KylgKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cblxuZnVuY3Rpb24gZmluZFJvdXRlKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgb3B0cykge1xuICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBjb25zdCBzdGF0aWNOb2RlID0gY3R4LnN0YXRpY1twYXRoXTtcbiAgaWYgKHN0YXRpY05vZGUgJiYgc3RhdGljTm9kZS5tZXRob2RzKSB7XG4gICAgY29uc3Qgc3RhdGljTWF0Y2ggPSBzdGF0aWNOb2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBzdGF0aWNOb2RlLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKHN0YXRpY01hdGNoICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0aWNNYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gIGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk/LlswXTtcbiAgaWYgKG1hdGNoID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdHM/LnBhcmFtcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBtYXRjaC5kYXRhLFxuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zTWFwID8gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIG1hdGNoLnBhcmFtc01hcCkgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIF9sb29rdXBUcmVlKGN0eCwgbm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAobm9kZS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLnBhcmFtICYmIG5vZGUucGFyYW0ubWV0aG9kcykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLnBhcmFtLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLnBhcmFtLm1ldGhvZHNbXCJcIl07XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcbiAgICAgICAgaWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcbiAgICAgICAgaWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgY29uc3Qgc3RhdGljQ2hpbGQgPSBub2RlLnN0YXRpY1tzZWdtZW50XTtcbiAgICBpZiAoc3RhdGljQ2hpbGQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnBhcmFtKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuICAgIHJldHVybiBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiByZW1vdmVSb3V0ZShjdHgsIG1ldGhvZCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgcmV0dXJuIF9yZW1vdmUoY3R4LnJvb3QsIG1ldGhvZCB8fCBcIlwiLCBzZWdtZW50cywgMCk7XG59XG5mdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kcyAmJiBtZXRob2QgaW4gbm9kZS5tZXRob2RzKSB7XG4gICAgICBkZWxldGUgbm9kZS5tZXRob2RzW21ldGhvZF07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5tZXRob2RzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5tZXRob2RzID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICAgIF9yZW1vdmUobm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICAgIGlmIChfaXNFbXB0eU5vZGUobm9kZS5wYXJhbSkpIHtcbiAgICAgICAgbm9kZS5wYXJhbSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzZWdtZW50ID09PSBcIioqXCIpIHtcbiAgICBpZiAobm9kZS53aWxkY2FyZCkge1xuICAgICAgX3JlbW92ZShub2RlLndpbGRjYXJkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKF9pc0VtcHR5Tm9kZShub2RlLndpbGRjYXJkKSkge1xuICAgICAgICBub2RlLndpbGRjYXJkID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGROb2RlID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgaWYgKGNoaWxkTm9kZSkge1xuICAgIF9yZW1vdmUoY2hpbGROb2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgIGlmIChfaXNFbXB0eU5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgZGVsZXRlIG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5vZGUuc3RhdGljKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfaXNFbXB0eU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5tZXRob2RzID09PSB2b2lkIDAgJiYgbm9kZS5zdGF0aWMgPT09IHZvaWQgMCAmJiBub2RlLnBhcmFtID09PSB2b2lkIDAgJiYgbm9kZS53aWxkY2FyZCA9PT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxsUm91dGVzKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgb3B0cykge1xuICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgY29uc3QgbWF0Y2hlcyA9IF9maW5kQWxsKGN0eCwgY3R4LnJvb3QsIG1ldGhvZCwgc2VnbWVudHMsIDApO1xuICBpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcCgobSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBtLmRhdGEsXG4gICAgICBwYXJhbXM6IG0ucGFyYW1zTWFwID8gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIG0ucGFyYW1zTWFwKSA6IHZvaWQgMFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gX2ZpbmRBbGwoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCwgbWF0Y2hlcyA9IFtdKSB7XG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gIGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykge1xuICAgIGNvbnN0IG1hdGNoID0gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICBfZmluZEFsbChjdHgsIG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSwgbWF0Y2hlcyk7XG4gICAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG4gIGlmIChzdGF0aWNDaGlsZCkge1xuICAgIF9maW5kQWxsKGN0eCwgc3RhdGljQ2hpbGQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSwgbWF0Y2hlcyk7XG4gIH1cbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggJiYgbm9kZS5tZXRob2RzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBub2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZXhwb3J0IHsgYWRkUm91dGUsIGNyZWF0ZVJvdXRlciwgZmluZEFsbFJvdXRlcywgZmluZFJvdXRlLCByZW1vdmVSb3V0ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;